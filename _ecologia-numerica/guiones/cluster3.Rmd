---
title: "Análisis Aglomerativo III"
author: "Universidad Nacional de Colombia, Sede Medellín"
date: "Viernes, 23 de octubre de 2015"
output: 
  html_document: 
    toc: yes
---



```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=11, 
                      fig.height=11)
```


## Lectura de las bases de datos

```{r}
# Lectura
ambient       <- read.csv2("ambientales.csv",enc="latin1",row.names=1)
peces         <- read.csv2("peces.csv",enc="latin1",row.names=1)
locs          <- read.csv2("localidades.csv",enc="latin1",row.names=1)
nomEspec      <- read.csv2("nombresdeespecies.csv",enc="latin1")
nomVarAmbient <- read.csv2("Nombresdevariablesambientales.csv",enc="latin1")

# Adecuación
# Quitar el sitio que no tiene ninguna especie
sumEsp  <- apply(peces,1,sum)
peces   <- peces[sumEsp!=0,]
ambient <- ambient[sumEsp!=0,]
locs    <- locs[sumEsp!=0,]

```

## Carga de paquetes requeridos

```{r}
# (vegan deberá ser cargado después de ade4 para evitar conflictos).
library(ade4)
library(vegan)
library(gclus)
library(cluster)
library(RColorBrewer)
#library(labdsv)
```
## Carga de funciones auxiliares
```{r}
# Carga de funciones adicionales en archivos de scripts en R.
source("hcoplot.R")
source("test.a.R")
source("coldiss.R")
```


```{r}
# Cálculo de la matriz utilizando la distancia de Chord
# entre sitios, siguiente en enlace simple.
peces.norm <- decostand(peces, "normalize")
peces.ch <- vegdist(peces.norm, "euc")
peces.ch.single <- hclust(peces.ch, method="single")
# Gráfica del dendograma usando las opciones por omisión.
plot(peces.ch.single,main="Peces - Chord - Enlace simple")

# Cálculo utilizand el enlace completo
peces.ch.complete <- hclust(peces.ch, method="complete")
plot(peces.ch.complete,main="Peces - Chord - Enlace completo")

# Cálculo mediante UPGMA
peces.ch.UPGMA <- hclust(peces.ch, method="average")
plot(peces.ch.UPGMA,main="Peces - Chord - Promedio")

# Cálculo mediante UPGMC
peces.ch.centroid <- hclust(peces.ch, method="centroid")
plot(peces.ch.centroid,main="Peces - Chord - Centroide")

# Utilizando el métod de Ward
peces.ch.ward <- hclust(peces.ch, method="ward.D")
plot(peces.ch.ward,main="Peces - Chord - Ward")

# Transformación raiz cuadrada de la altura
peces.ch.ward$height <- sqrt(peces.ch.ward$height)
plot(peces.ch.ward,main="Peces - Chord - sqrt(Ward)")

```

## Correlaciones cofenéticas

```{r}

# Agrupamiento mediante enlace simple
peces.ch.single.coph <- cophenetic(peces.ch.single)
cor(peces.ch, peces.ch.single.coph)
# Agrupamiento mediante enlace completo
peces.ch.comp.coph <- cophenetic(peces.ch.complete)
cor(peces.ch, peces.ch.comp.coph)
# Agrupamiento mediante promedios
peces.ch.UPGMA.coph <- cophenetic(peces.ch.UPGMA)
cor(peces.ch, peces.ch.UPGMA.coph)
# Agrupamiento mediante ward
peces.ch.ward.coph <- cophenetic(peces.ch.ward)
cor(peces.ch, peces.ch.ward.coph)
cor(peces.ch, peces.ch.ward.coph, method="spearman")
```

## Diagramas de Shepard

```{r}
op<-par(no.readonly=TRUE)
par(mfrow=c(2,2))
plot(peces.ch, peces.ch.single.coph, xlab="Distancia Chord", 
	ylab="Distancia cofenética", asp=1, xlim=c(0,sqrt(2)), ylim=c(0,sqrt(2)),
	main=c("Enlace simple", paste("Correlación cofenética =",
	round(cor(peces.ch, peces.ch.single.coph),3))))
abline(0,1)
lines(lowess(peces.ch, peces.ch.single.coph), col="red")
plot(peces.ch, peces.ch.comp.coph, xlab="Distancia Chord", 
	ylab="Distancia cofenética", asp=1, xlim=c(0,sqrt(2)), ylim=c(0,sqrt(2)),
	main=c("Enlace completo", paste("Correlación cofenética =",
	round(cor(peces.ch, peces.ch.comp.coph),3))))
abline(0,1)
lines(lowess(peces.ch, peces.ch.comp.coph), col="red")
plot(peces.ch, peces.ch.UPGMA.coph, xlab="Distancia Chord", 
	ylab="Distancia cofenética", asp=1, xlim=c(0,sqrt(2)), ylim=c(0,sqrt(2)),
	main=c("UPGMA", paste("Correlación cofenética =",
	round(cor(peces.ch, peces.ch.UPGMA.coph),3))))
abline(0,1)
lines(lowess(peces.ch, peces.ch.UPGMA.coph), col="red")
plot(peces.ch, peces.ch.ward.coph, xlab="Distancia Chord", 
	ylab="Distancia cofenética", asp=1, xlim=c(0,sqrt(2)), 
	ylim=c(0,max(peces.ch.ward$height)),
	main=c("Agrupamiento de Ward", paste("Correlación cofenética =",
	round(cor(peces.ch, peces.ch.ward.coph),3))))
abline(0,1)
lines(lowess(peces.ch, peces.ch.ward.coph), col="red")
par(op)
```

## Distancia de Gower

```{r}
(gow.dist.single <- sum((peces.ch-peces.ch.single.coph)^2))
(gow.dist.comp <- sum((peces.ch-peces.ch.comp.coph)^2))
(gow.dist.UPGMA <- sum((peces.ch-peces.ch.UPGMA.coph)^2))
(gow.dist.ward <- sum((peces.ch-peces.ch.ward.coph)^2))
```

## Gráficas de los valores de niveles de fusión

```{r}
op<-par(no.readonly=TRUE)
#windows(title="Nivel de fusión", 12, 8)
par(mfrow=c(2,2))
plot(peces.ch.single$height, nrow(peces):2, type="S", 
	main="Nivel de fusión - Chord - Simple", 
	ylab="k (número de grupos)", xlab="h (altura del nodo)", col="grey")
text(peces.ch.single$height, nrow(peces):2, nrow(peces):2, col="red", cex=0.8)
plot(peces.ch.complete$height, nrow(peces):2, type="S", 
	main="Nivel de fusión - Chord - Completo", 
	ylab="k (número de grupos)", xlab="h (altura del nodo)", col="grey")
text(peces.ch.complete$height, nrow(peces):2, nrow(peces):2, col="red", cex=0.8)
plot(peces.ch.UPGMA$height, nrow(peces):2, type="S", 
	main="Nivel de fusión - Chord - UPGMA", 
	ylab="k (número de grupos)", xlab="h (altura del nodo)", col="grey")
text(peces.ch.UPGMA$height, nrow(peces):2, nrow(peces):2, col="red", cex=0.8)
plot(peces.ch.ward$height, nrow(peces):2, type="S", 
	main="Nivel de fusión - Chord - Ward", 
	ylab="k (número de grupos)", xlab="h (altura del nodo)", col="grey")
text(peces.ch.ward$height, nrow(peces):2, nrow(peces):2, col="red", cex=0.8)
par(op)
```

## Selección del número de grupos

```{r}

# Cortar los dendrrograms para comparar la membresía de lso grupos entre si.
# Mediante tablas de contingencia.

# Tomemos un mismo número de grupos para todos.
k <- 4 # Número de grupo donde es el menor número de grupos que
       # muestra un salto importante en las gráficas de fusión.
# Corte de los dendrogramas
pecesbc.single.g <- cutree(peces.ch.single, k)
pecesbc.complete.g <- cutree(peces.ch.complete, k)
pecesbc.UPGMA.g <- cutree(peces.ch.UPGMA, k)
pecesbc.ward.g <- cutree(peces.ch.ward, k)
```

## Comparación entre agrupaciones

```{r}
# Comparación de la clasificación mediante la construcción
# de tablas de contingencia.
# Enlace simple vs completo
table(pecesbc.single.g, pecesbc.complete.g)
# Enlaces simple vs UPGMA
table(pecesbc.single.g, pecesbc.UPGMA.g)
# Enlaces simple vs Ward
table(pecesbc.single.g, pecesbc.ward.g)
# Enlace completo vs UPGMA
table(pecesbc.complete.g, pecesbc.UPGMA.g)
# Enlace completo vs Ward
table(pecesbc.complete.g, pecesbc.ward.g)
# UPGMA vs Ward
table(pecesbc.UPGMA.g, pecesbc.ward.g)

```

## Siluetas

```{r}
# Silueta

plot(silhouette(cutree(peces.ch.ward, k=4), peces.ch))

plot(silhouette(cutree(peces.ch.ward, k=5), peces.ch))

# Número de cluster óptimos de acuerdo a las anchuras de la siluetas.
# (Índice de calidad de Rousseeuw).
# Promedio de ancho de la silueta.
# (ASW=Average silhouette width)



# Gráficas del promedio de las anchuras de las siluetas
# utilizando el agrupamiento de Ward para todas las particiones
# exceptuando la partición trivial de un solo grupo (k=1)
# Primero se crea un vector vacío en el cual se acumularán
# los valores de ASW.
asw <- numeric(nrow(peces))
for (k in 2:(nrow(peces)-1)) {
	sil <- silhouette(cutree(peces.ch.ward, k=k), peces.ch)
	asw[k] <- summary(sil)$avg.width
	}
k.best <- which.max(asw)
op<-par(no.readonly=TRUE)
plot(1:nrow(peces), asw, type="h", 
	main="Número óptimo de grupos con las siluetas, Ward", 
	xlab="k (número de grupos)", ylab="Promedio del ancho de la silueta")
axis(1, k.best, paste("óptimo",k.best,sep="\n"), col="red", font=2,
	col.axis="red")
points(k.best, max(asw), pch=16, col="red", cex=1.5)
cat("", "Número de grupos óptimos por silueta =", k.best, "\n", 
	"con un promedio del ancho de la silueta de", max(asw), "\n")
par(op)

```

