---
title: Programación paralela
author: "Kenneth Cabrera"
date: "28/10/2014"
output: html_document
---

```{r}
# Número de iteraciones en el ciclo
iters<-10

# Vector para almacenar la salida
lista<-vector('list',length=iters)
 
# Inicio del tiempo de computación
tiempoIni<-Sys.time()

# Ciclo
for(i in 1:iters){
 
    # contador
    cat(i,'\n')
 
    elem.lista<-rnorm(1e6)
    elem.lista<-summary(elem.lista)
     
    # salida
    lista[[i]]<-elem.lista
         
    }
 
# Tiempo de finalización
print(Sys.time()-tiempoIni)
# Tiempo utilizado

```



```{r}
# Diferentes escenarios en número de interaciones
iters<-seq(10,100,by=30)
 
# Guardar el tiempo para los diferentes escenarios de iteración
tiempos<-numeric(length(iters))
 
# Ciclo para los distintos escenarios
for(val in 1:length(iters)){
     
    cat('Escenario ', val,' de ', length(iters),'\n')
     
    to.iter<-iters[val]
     
    # Vector para acumular la salida
    lista<-vector('list',length=to.iter)
 
    # Inicio del tiempo para el escenario
    tiempoIni<-Sys.time()
 
    # El mismo ciclo del caso anterior
    for(i in 1:to.iter){
     
        cat(i,'\n')
         
        elem.lista<-rnorm(1e6)
        elem.lista<-summary(elem.lista)
         
        # salida
        lista[[i]]<-elem.lista
         
        }
 
    # Finalización del tiempo
    tiempos[val]<-Sys.time()-tiempoIni
     
    }
 
# Graficación del tiempo en cada escenario
require(ggplot2)
 
para.graf<-data.frame(iters,tiempos)
ggplot(para.graf,aes(x=iters,y=tiempos)) + 
    geom_point() +
    geom_smooth(method=lm, se=FALSE) + 
    theme_bw() + 
    scale_x_continuous('Escenario del número de iteraciones') + 
    scale_y_continuous ('Tiempo en segundos')
```


```{r}
# Modelo para predecir tiempo para las iteracciones
mod<-lm(tiempos~iters)
predict(mod,newdata=data.frame(iters=5e2))/60
```



```{r}
# Paquetes para el paralelismo
require(foreach)
require(doParallel)

# Número de iteraciones
iters<-5e2
 
# Establecer paralelismo con 2 procesadores en paralelo
cl<-makeCluster(2)
registerDoParallel(cl)
 
# Tiempo de inicio
tiempoIni<-Sys.time()

# ciclo

ls<-foreach(icount(iters)) %dopar% {
     
    to.ls<-rnorm(1e6)
    to.ls<-summary(to.ls)
    to.ls
     
    }
 
print(Sys.time()-tiempoIni)
stopCluster(cl)
```


